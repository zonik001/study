<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!--1. <div>
        <p></p>
        <span>
            <strong></strong>
            <b></b>
        </span>
    </div> -->

    <div><strong><span><i></i></span></strong></div> <!-- 2.-->
    <script>
        // 1.遍历元素节点数（在原型链上编程）
        // var div = document.getElementsByTagName('div')[0];


        // 2.封装函数，返回元素e的第n层祖先元素节点
        function retParent(elem, n) {
            while (elem && n) {
                elem = elem.parentElement;
                n--;
            }
            return elem;
        }
        var i = document.getElementsByTagName('i')[0];

        // 3.封装函数，返回元素e的第n个兄弟节点，n为正，返回后面元素的兄弟节点，n为负，返回前面的，n为0，返回自己。
        function retSibling (e, n) {

        }

        // 4.编辑函数，封装myChildren功能，解决以前部分浏览器的兼容问题
            // 使用childNodes
            Element.prototype.mychildren = function () {
                var child = this.childNodes;
                var len = child.length;
                var arr = [];
                for(var i = 0; i < len; i ++){
                    if(child[i].nodeType == 1) {
                        arr.push(child[i]);
                    }
                }
                return arr;
            }

        // 5.封装hasChildren() 方法，不使用children属性


        // 6.封装函数insertAfter():
        Element.prototype.insertAfter = function (targetNode,afterNode) {
            var beforeNode = afterNode.nextElementsibling;
            if(beforeNode == null) {
                // this.targetNode = targetNode;  写的是啥
                this.appendChild(targetNode);
            }else{
                this.insertAfter(targetNode,beforeNode);
            }
        }

        // 7.将目标节点内部的节点顺序逆序


    </script>
</body>

</html>