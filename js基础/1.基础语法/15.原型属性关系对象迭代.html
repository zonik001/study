<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        function Person() {

        }
        console.log(typeof(Person.prototype));
        console.log(Person.prototype);  
        console.log(Person.__proto__); //3.对象迭代.html:15 ƒ () { [native code] }
        console.log(Person.prototype.constructor);//ƒ Person() {}
        console.log(Person.prototype.constructor === Person);  //true
        console.log(Person.prototype.__proto__);
        // 原型对象的原型对象指向Object的圆形对象?
        console.log(Person.prototype.__proto__ === Object.prototype); //true
        console.log(Person.prototype.__proto__.constructor === Object); //true
        console.log(Person.prototype.__proto__.__proto__ === null) //Object对象的原型为空
        let person1 = new Person();
        let Person2 = new Person();
        // console.log(person1.prototype.constructor === person1);  error 实例自己的原型不能被访问，用的是构造函数的原型
        console.log(person1 !== Person.prototype); //true 实例对象也不等于原型对象

        // **每个对象都有一个__proto__属性**，通过__proto__属性链接到原型对象
        console.log(person1.__proto__ === Person.prototype);  // true
        var obj = {
            name : 'newdie'
        }
        person1.__proto__ = obj;  //__proto__属性可以修改  这里原型修改成obj对象了
        console.log(person1.name);



        //对象迭代
        // const obj = {
        //     foo : "bar",
        //     baz : 1,
        //     o : {}
        // }
        // console.log(Object.values(obj));   //Object.values  返回对象值的数组
        // console.log(Object.entries(obj));  //Objext.values  返回键值对的数组


    </script>
</body>
</html>